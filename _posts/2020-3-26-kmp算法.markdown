---
tags
- 编程及算法
---

KMP算法字符串匹配的一种优化算法，暴力匹配的时间复杂度为o（mn），而kmp算法的时间复杂度为o（m+n）（m为主串长度，n为模式串长度）<br>

kmp算法主要利用的是已经匹配过的字符不需要再次匹配的原理。

# 理论部分

## 前后缀

举例说明，对于一串字符abcad来说，a，ab，abc，abca便是其前缀，d，ad，cad，bcad就是其后缀。<br>

对于一串模式串来说，我们需要在每一个该模式串的前缀串中找到一个前缀使得该前缀长度最长而且与相同长度的后缀一一匹配。<br>

举例说明：对于ababa这个模式串来说，有a，ab，aba，abab四个前缀。<br>

对于a来说,无前后缀，记为0；对于ab来说也是0；对于aba来说，前缀a与后缀b匹配且长度最长，记为1；对于abab来说，前缀ab与后缀ab匹配且长度最长，记为2；

## next

前后缀在匹配中有什么用呢？当主串的第i个数和模式串的第j个数不匹配时，我们首先可以确定主串第i个数前面的数与模式串第j个数前面的数一一匹配，那么我们在移动模式串的时候只需要将模式串中第j个数前的数组成的串里的最大前缀移动到其最大后缀的地方就可以了<br>

举例 主串为abcabc，模式串为abcaba；
当i和j都移动到最后一位时，明显失配，但此时可以保证主串的第i个数的串abcab（记为l1）和模式串中第j个数前的数组成的串abcab（l2）一致。此时只需要将l2的前缀移动到l1的某个后缀且保证l2的前缀与该l1的后缀相同即可。由于l1和l2实际上是一个串，所以就变成了前后缀里面所讨论的问题。<br>

在该例子中即把前缀ab移动到后缀ab的地方就可以，也就是把c（对应数组下标为2，下标数字2正好为前缀的长度）移动到主串的第i个位置。由此定义出next函数的概念。<br>

NEXT（j）=k为当模式串中的第 j 个字符与主串中的相应字符(设为第 i 个字符)失配时，需要把模式串右移，使得模式串中的第 k 个字符与主串中的第 i 个字符对齐。(不难发现这里的k就等于我们要找的前缀长度）
