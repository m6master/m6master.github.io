---
tags:
- 编程及算法
---

KMP算法字符串匹配的一种优化算法，暴力匹配的时间复杂度为o（mn），而kmp算法的时间复杂度为o（m+n）（m为主串长度，n为模式串长度）<br>

kmp算法主要利用的是已经匹配过的字符不需要再次匹配的原理。

# 理论部分

## 前后缀

举例说明，对于一串字符abcad来说，a，ab，abc，abca便是其前缀，d，ad，cad，bcad就是其后缀。<br>

对于一串模式串来说，我们需要在每一个该模式串的前缀串中找到一个前缀使得该前缀长度最长而且与相同长度的后缀一一匹配。<br>

举例说明：对于ababa这个模式串来说，有a，ab，aba，abab四个前缀。<br>

对于a来说,无前后缀，记为0；对于ab来说也是0；对于aba来说，前缀a与后缀b匹配且长度最长，记为1；对于abab来说，前缀ab与后缀ab匹配且长度最长，记为2；

## next

### next数组的作用以及计算原理

前后缀在匹配中有什么用呢？当主串的第i个数和模式串的第j个数不匹配时，我们首先可以确定主串第i个数前面的数与模式串第j个数前面的数一一匹配，那么我们在移动模式串的时候只需要将模式串中第j个数前的数组成的串里的最大前缀移动到其最大后缀的地方就可以了<br>

举例 主串为abcabc，模式串为abcaba；
当i和j都移动到最后一位时，明显失配，但此时可以保证主串的第i个数的串abcab（记为l1）和模式串中第j个数前的数组成的串abcab（l2）一致。此时只需要将l2的前缀移动到l1的某个后缀且保证l2的前缀与该l1的后缀相同即可。由于l1和l2实际上是一个串，所以就变成了前后缀里面所讨论的问题。<br>

在该例子中即把前缀ab移动到后缀ab的地方就可以，也就是把c（对应数组下标为2，下标数字2正好为前缀的长度）移动到主串的第i个位置。由此定义出next函数的概念。<br>

NEXT（j）=k为当模式串中的第 j 个字符与主串中的相应字符(设为第 i 个字符)失配时，需要把模式串右移，使得模式串中的第 k 个字符与主串中的第 i 个字符对齐。(不难发现这里的k就等于我们要找的前缀长度<br>

因而求next即为求其最大前缀数组，这里采用递推的思路，next[j]=k 表明：
 p0⋯p(k−1)=p(j-k)⋯p(j−1)，并且不存在 k′>k 满足此式。<br>

1.若 pk=pj，则 p0⋯pk=pk(j-k)⋯pj，所以
     next[j+1]=k+1=next[j]+1。

2.若 pk≠pj，则 p0⋯pk≠p(j-k)⋯pj，那么此时需要在p0...pk中找到一个pm将其移动到pj的位置并保证pm之前的串和pj之前的串相同，听起来是不是很像next的定义？若把原模式串看成主串，把 p0...pk 看成模式串，则就是求一个next[k]。找到pm后此时有p0⋯p(m-1)=p(j-m)⋯p(j-1)     <br>

若 pm=pj，则 p0⋯pm=p(j-m)⋯pj,此时找到了最大前缀，所以
     next[j+1]=next[k]+1。

若 不相等则按同样的办法继续递推。

### next数组的代码实现

```c
void CalculateNext(SeqString* p, int next[ ]) {
    int j=0, k=-1;
    next[0]=-1;
    while(j<p->length){
        if (k<0 || p->pCharArray[k]==p->pCharArray[j]) {
            next[j+1]=k+1;
            j++;
            k++;
        }
	else {
            k=next[k];  
           /* 模式串右移，使j和next[k]对齐，与自身匹配。
            * 如果一直递归下去，当k=-1时，得next[j+1]=0，
            * 这是在前面的if分支里处理的。*/            
        }
    }  /* End of while */
    return;
}
```



