---
tags:
- 编程及算法
---

# 题目

红人无数的红帽侠决定金盆洗手啦！<br>
由于红帽侠后继无人，按照祖祖辈辈的祖训，红帽侠要把位置传给这个王国里红帽最少的那个人。<br>
但是，红帽侠曾记得那个被红的晚上，而那个人，还在王国里潇潇洒洒。<br>
“当然是选择 不 原谅他啊！”<br>
于是红帽侠搬出了祖辈流传的神器：红帽自动机——对着一个人喊一声，“你将加冕为王”，除了他以外的所有人，都被戴上一顶红帽。<br>
红帽侠决定金盆洗手前，再干一票！<br>
不为别的，就为了让当初曾经红了他的人成为这个王国内唯一的红帽最多的人！<br>
“屏幕前的你，如果不想被我戴上红帽的话，就帮我算算，我最少需要喊多少次吧。这条咸鱼还没熟，我要再烤烤。”<br>

第一行两个整数n,xn,x(2≤n≤100000,1≤x≤n),表示这个王国有n个人，红帽侠希望第x个人红帽最多。<br>
第二行包括n个整数，用空格隔开，第i个整数gi​表示第i个人头上有gi顶红帽。(0≤gi≤10000)<br>

## Standard Output

输出一个整数aaa，表示红帽侠最少需要喊aaa次“你将加冕为王”。

### Samples

```
Input	   Output
5 3         4
1 1 3 4 4	


4 2         0
0 3 2 1    
```
### Note

>Sample 1:
第1次，对第4人喊“你将加冕为王”，整体红帽变为 [ 2 2 4 4 5 ]
第2次，对第5人喊“你将加冕为王”，整体红帽变为 [ 3 3 5 5 5 ]
第3次，对第4人喊“你将加冕为王”，整体红帽变为 [ 4 4 6 5 6 ]
第4次，对第5人喊“你将加冕为王”，整体红帽变为 [ 5 5 7 6 6 ]
此时，第3人红帽最多。
可以证明，至少需要4次。
Sample 2:
第2人红帽最多，不需喊。

# 代码

```
#include<stdio.h>
 int main(void)
 {
 	int n,x,jian=0,a=0;
	scanf("%d",&n);
	scanf("%d",&x);
	int g[n];
	for(int i=0;i<n;i++)
	{
		scanf("%d",&g[i]);
	}
	for(int i=0;i<n;i++)
	{
		if(g[i]>=g[x-1])
		{
			jian=g[i]-g[x-1];
			a=a+jian+1;
		}
	}
	a=a-1;
	printf("%d",a);
	return 0;
 }
```

# 总结分析

其实具体算法也不是我想出来的。除了被喊得以外都加一，就相当于被喊得减一。
实现过程中，数组的类型出了大问题。（果然不能无脑char
